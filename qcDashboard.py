import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
import plotly.graph_objects as go
import pandas as pd
import numpy as np
import cv2
import time

from functions import loadContourQAImg
from imgAug import normalize_equalize_smooth_CT, window_image


def frame_args(duration):
    return {
        "frame": {"duration": duration},
        "mode": "immediate",
        "fromcurrent": True,
        "transition": {"duration": duration, "easing": "linear"},
    }


# Initialize global variables, DB
masterStructureList = "G:\\Projects\\mimTemplates\\StructureListMaster.xlsx"
structureListFile = pd.read_excel(masterStructureList)
structureList = [x.upper() for x in structureListFile['StructureName'].to_list()]

HDF5_DIR = "H:\\Treatment Planning\\Elguindi\\storage"
contourDatabase = "H:\\Treatment Planning\\Elguindi\\contourDatabase\\contourDB.xlsx"
db = pd.read_excel(contourDatabase, index=False)

# toCompare = [testContour, refContour]
toCompare = ['autoGenerated', 'mimLatest']

metricSelectionOptions = ['APL', 'TP volume', 'FN volume', 'FP volume', 'SEN', '%FP',
                          '3D DSC', '2D HD', '95% 2D HD', 'Ave 2D Dist', 'Median 2D Dist',
                          'Reference Centroid', 'Test Centroid', 'SDSC_1mm', 'SDSC_3mm',
                          'RobustHD_95', 'ref_vol', 'test_vol']

db.index = db['SCAN_DATE']


# DASH APP
external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']

app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

app.layout = html.Div(children=[

    html.H1(children='QC Dashboard'),

    html.Div(children='''
    Explore each organ segmentation at MSKCC
    '''),

    html.Div([

        dcc.Dropdown(
            id='dropdownOrganSelection',
            options=[{'label': i, 'value': i} for i in structureList],
            value=structureList[0]
            ),

        dcc.Dropdown(
            id='dropdownMetricSelection',
            options=[{'label': i, 'value': i} for i in metricSelectionOptions],
            value=metricSelectionOptions[0]
        ),

        dcc.Graph(
            id='quantitative-graph'
            ),

    ],
        className="row flex-display",
    ),

    html.Div([
        dcc.Graph(id='segmentationDisplay')
    ]),

    # Hidden div inside the app that stores processed data (if needed)
    html.Div(id='intermediate-data', style={'display': 'none'})

])


@app.callback(
    Output('quantitative-graph', 'figure'),
    [Input('dropdownOrganSelection', 'value'),
     Input('dropdownMetricSelection', 'value')])
def update_figure(organName, comparisonMetric):
    columnName = organName + '_' + comparisonMetric

    if comparisonMetric == 'APL':
        y_val = db[columnName]/10
    else:
        y_val = db[columnName]

    fig = go.Figure(go.Scatter(
        x=db['SCAN_DATE'],
        y=y_val,
        mode='markers'
    ))

    fig.update_xaxes(
        rangeslider_visible=True,
        tickformatstops=[
            dict(dtickrange=[None, 1000], value="%H:%M:%S.%L ms"),
            dict(dtickrange=[1000, 60000], value="%H:%M:%S s"),
            dict(dtickrange=[60000, 3600000], value="%H:%M m"),
            dict(dtickrange=[3600000, 86400000], value="%H:%M h"),
            dict(dtickrange=[86400000, 604800000], value="%e. %b d"),
            dict(dtickrange=[604800000, "M1"], value="%e. %b w"),
            dict(dtickrange=["M1", "M12"], value="%b '%y M"),
            dict(dtickrange=["M12", None], value="%Y Y")
        ]
    )

    if 'DSC' in columnName:
        rangeVal = [0, 1.01]
    else:
        rangeVal = [0, y_val.max()*1.03]

    fig.update_yaxes(
        range=rangeVal
    )

    return fig


@app.callback(Output('segmentationDisplay', 'figure'),
              [Input('quantitative-graph', 'clickData'),
               Input('dropdownOrganSelection', 'value'),
               Input('dropdownMetricSelection', 'value')])
def load_data(clickData, organName, comparisonMetric):
    height = width = 128
    if clickData is not None:
        t0 = time.time()
        highlightedColumn = organName + '_' + comparisonMetric
        contourFile_test = organName + '_' + toCompare[0]
        contourFile_ref = organName + '_' + toCompare[1]
        print(highlightedColumn)
        rowData = db.loc[(db['SCAN_DATE'] == clickData['points'][0]['x']) & (
                    db[highlightedColumn] == clickData['points'][0]['y'] * 10)]
        mask, mask_test, scan, bbox = loadContourQAImg(rowData[contourFile_ref].iloc[0],
                                                       rowData[contourFile_test].iloc[0],
                                                       rowData['SCAN_FILE'].iloc[0], HDF5_DIR, returnMask=False)
        bbox = [bbox[2], bbox[3], bbox[4], bbox[5], bbox[0], bbox[1]]

        t1 = time.time()
        print('Time to Load Data: ', str(t1 - t0))

        t0 = time.time()
        WL = [40, 350]
        scan_norm = normalize_equalize_smooth_CT(scan.squeeze(), 1, WL)
        scan = scan_norm.transpose(2, 3, 0, 1)
        mask = mask.transpose(1, 2, 0, 3)
        mask_test = mask_test.transpose(1, 2, 0, 3)

        centroid_contour = [int(np.mean([bbox[0], bbox[1] + 1])), int(np.mean([bbox[2], bbox[3] + 1])),
                            int(np.mean([bbox[4], bbox[5] + 1]))]

        scan_arr = scan[centroid_contour[0] - int(height / 2):centroid_contour[0] + int(height / 2),
                   centroid_contour[1] - int(height / 2):centroid_contour[1] + int(height / 2),
                   int(bbox[4]) - 5:int(bbox[5]) + 5, :]

        mask_arr_add = mask[centroid_contour[0] - int(height / 2):centroid_contour[0] + int(height / 2),
                       centroid_contour[1] - int(height / 2):centroid_contour[1] + int(height / 2),
                       int(bbox[4]) - 5:int(bbox[5]) + 5]

        # mask_arr_add = addedVol[centroid_contour[0] - int(height / 2):centroid_contour[0] + int(height / 2),
        #                centroid_contour[1] - int(height / 2):centroid_contour[1] + int(height / 2),
        #                int(bbox[4]) - 5:int(bbox[5]) + 5]
        #
        # mask_arr_sub = subVol[centroid_contour[0] - int(height / 2):centroid_contour[0] + int(height / 2),
        #                centroid_contour[1] - int(height / 2):centroid_contour[1] + int(height / 2),
        #                int(bbox[4]) - 5:int(bbox[5]) + 5]
        #
        mask_arr_auto = mask_test[centroid_contour[0] - int(height / 2):centroid_contour[0] + int(height / 2),
                        centroid_contour[1] - int(height / 2):centroid_contour[1] + int(height / 2),
                        int(bbox[4]) - 5:int(bbox[5]) + 5]

        coloredMask = np.zeros(np.shape(scan_arr))
        h, w, l, c = np.shape(coloredMask)
        coloredMask[:, :, :, 0] = (mask_arr_add.squeeze() * 255).astype('uint8')
        coloredMask[:, :, :, 1] = (mask_arr_auto.squeeze() * 255).astype('uint8')
        # coloredMask[:, :, :, 2] = (mask_arr_sub * -255).astype('uint8')
        displayImg = np.zeros(np.shape(scan_arr.astype('uint8')))

        frames = []
        for i in range(0, l):
            blended_img = cv2.addWeighted(coloredMask[:, :, i, :].astype('uint8'), 0.2,
                                          scan_arr[:, :, i, :].astype('uint8'), 0.8, 0)
            displayImg[:, :, i, :] = blended_img.astype('uint8')
            frames.append(go.Frame(data=go.Image(z=blended_img.astype('uint8')), name=str(i)))
        t1 = time.time()
        print('Time to Process Data: ', str(t1 - t0))
    else:
        displayImg = np.zeros((height, width, 1, 3))

    t0 = time.time()
    fig = go.Figure(frames=frames)
    fig.add_trace(go.Image(z=displayImg[:, :, 0, :].astype('uint8')))
    sliders = [
        {
            "pad": {"b": 10, "t": 60},
            "len": 0.9,
            "x": 0.1,
            "y": 0,
            "steps": [
                {
                    "args": [[f.name], frame_args(1)],
                    "label": str(k),
                    "method": "animate",
                }
                for k, f in enumerate(fig.frames)
            ],
        }
    ]

    fig.update_layout(
        title='Slices in volumetric data',
        width=600,
        height=600,
        updatemenus=[
            {
                "buttons": [
                    {
                        "args": [None, frame_args(50)],
                        "label": "&#9654;",  # play symbol
                        "method": "animate",
                    },
                    {
                        "args": [[None], frame_args(0)],
                        "label": "&#9724;",  # pause symbol
                        "method": "animate",
                    },
                ],
                "direction": "left",
                "type": "buttons",
                "x": 0.1,
                "y": 0,
            }
        ],
        sliders=sliders
    )

    t1 = time.time()
    print('Time to create figure: ', str(t1 - t0))
    return fig


if __name__ == '__main__':
    PORT = 8000
    ADDRESS = "172.25.132.135"
    app.run_server(debug=True,
                   port=PORT,
                   host=ADDRESS)
